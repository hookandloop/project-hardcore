#!/usr/bin/env node

/**
 * NOTE: All source code files generated by this script run from a `temp` folder placed
 * in the project root.  This script uses relative paths to link to files in the `src` folder.
 * The paths in these generated files may vary from the regular files used.
 *
 * Custom Build Steps:
 *
 * 1. Generate a list of component source code files based on what we've provided
 *    in args.  No args == all components.
 * 2. Sort requested components into a few logical groups (TBD) to be imported/exported
 *    in a specific order (which matters).
 * 3. Render both of the following:
 *    - an `index.js` file with ES6-based import/export statements
 *    - an `index.scss` file with SASS-based import statements
 * 4. Pass these files into Rollup/Node-Sass config and run the normal builds.
 * 5. Add the results of these builds to the `/dist` folder as usual.
 *
 * Order of included libraries matters per group:
 * - Core (required, canâ€™t be removed)
 * - Behaviors (not required but will be added if required by bundled components)
 * - Rules Libraries (Mask, Validation, Datagrid) (not required unless these components are used)
 * - Patterns
 * - Layouts
 * - Foundational Components
 * - Mid-Level Components (includes Charts)
 * - Complex Components
 */

const commandLineArgs = require('yargs').argv;

const chalk = require('chalk');
const { spawn } = require('child_process');
const del = require('del');
const fs = require('fs');
const path = require('path');

const logger = require('./logger');

const SRC_DIR = path.join(__dirname, '..', 'src');
const TEMP_DIR = path.join(__dirname, '..', 'temp');
const RELATIVE_SRC_DIR = path.join('..', 'src');

const filePaths = {
  src: {
    js: {
      behaviors: path.join(SRC_DIR, 'behaviors', 'behaviors.js'),
      components: path.join(SRC_DIR, 'components', 'components.js'),
      index: path.join(SRC_DIR, 'index.js'),
      initialize: path.join(SRC_DIR, 'behaviors', 'initialize', 'initialize.js'),
      patterns: path.join(SRC_DIR, 'patterns', 'patterns.js'),
    },
    jQuery: {
      behaviors: path.join(SRC_DIR, 'behaviors', 'behaviors.jquery.js'),
      components: path.join(SRC_DIR, 'components', 'components.jquery.js'),
      initialize: path.join(SRC_DIR, 'behaviors', 'initialize', 'initialize.jquery.js'),
      patterns: path.join(SRC_DIR, 'patterns', 'patterns.jquery.js'),
    },
    sass: {
      controls: path.join(SRC_DIR, 'core', '_controls.scss'),
      themes: {
        'dark-theme': path.join(SRC_DIR, 'themes', 'dark-theme.scss'),
        'high-contrast-theme': path.join(SRC_DIR, 'themes', 'high-contrast-theme.scss'),
        'light-theme': path.join(SRC_DIR, 'themes', 'light-theme.scss'),
        // 'uplift-theme': path.join(SRC_DIR, 'themes', 'uplift-theme.scss'),
      }
    }
  },
  target: {
    js: {
      behaviors: path.join(TEMP_DIR, 'behaviors.js'),
      components: path.join(TEMP_DIR, 'components.js'),
      index: path.join(TEMP_DIR, 'index.js'),
      initialize: path.join(TEMP_DIR, 'initialize.js'),
      patterns: path.join(TEMP_DIR, 'patterns.js'),
      rules: path.join(TEMP_DIR, 'rules.js')
    },
    jQuery: {
      behaviors: path.join(TEMP_DIR, 'behaviors.jquery.js'),
      components: path.join(TEMP_DIR, 'components.jquery.js'),
      initialize: path.join(TEMP_DIR, 'initialize.jquery.js'),
      patterns: path.join(TEMP_DIR, 'patterns.jquery.js')
    },
    sass: {
      controls: path.join(TEMP_DIR, '_controls.scss'),
      themes: {
        'dark-theme': path.join(TEMP_DIR, 'dark-theme.scss'),
        'high-contrast-theme': path.join(TEMP_DIR, 'high-contrast-theme.scss'),
        'light-theme': path.join(TEMP_DIR, 'light-theme.scss'),
        // 'uplift-theme': path.join(TEMP_DIR, 'uplift-theme.scss')
      }
    }
  }

};

// These search terms are used when scanning existing index files to determine
// a component's placement in a generated file.
const searchTerms = {
  complex: '// Complex ====/',
  foundational: '// Foundational ====/',
  mid: '// Mid ====/'
};

/*
// These are test arguments that can be used in place of command line arguments during debugging
const TEST_ARGS = [
  'builder',
  'button',
  'input',
  'mask',
  'listview',
  'list-detail',
  'longpress',
  'object-summary',
  'panes',
  'popupmenu',
  'tabs',
  'validation'
];
*/

// Library types
const libTypes = ['components', 'behaviors', 'layouts', 'patterns', 'utils'];

// All incoming scanned source code is labeled as "components" by default.
// If the source code folder shows up as a property here, it will be moved to a different
// bucket.
const customLocations = {
  masks: 'rules',
  'mask-api': '',
  'mask-input': 'foundational',
  _tabs: 'mid',
  '_tabs-horizontal': 'mid',
  '_tabs-vertical': 'mid',
  'tabs-multi': 'complex',
  '_multi-tabs': 'complex',
  '_tabs-module': 'complex',
  '_tabs-header': 'complex',
  validation: 'rules',
  'validation.utils': '',
  validator: 'foundational'
};

// Map for converting certain filenames to a dash-based string
// TODO: actually rename these files and better organize the source code. (see #833)
const dashSeparatedFileNames = {
  applicationmenu: 'application-menu',
  busyindicator: 'busy-indicator',
  circlepager: 'circle-pager',
  colorpicker: 'color-picker',
  compositeform: 'composite-form',
  contextualactionpanel: 'contextual-action-panel',
  datepicker: 'date-picker',
  emptymessage: 'empty-message',
  expandablearea: 'expandable-area',
  fileupload: 'file-upload',
  fileuploadadvanced: 'file-upload-advanced',
  listbuilder: 'list-builder',
  listfilter: 'list-filter',
  listview: 'list-view',
  monthview: 'month-view',
  multiselect: 'multi-select',
  popupmenu: 'popup-menu',
  searchfield: 'search-field',
  signin: 'sign-in',
  stepchart: 'step-chart',
  swaplist: 'swap-list',
  multitabs: 'tabs-multi', // (change)
  timepicker: 'time-picker',
  toolbarsearchfield: '' // don't actually include this one, cancel it out
};

const lowercaseConstructorNames = {
  masks: 'masks',
  longpress: 'longPress',
  renderloop: 'renderLoop'
};

// Storage buckets for relevant file paths.
// These get used for generating import/export statements
const buckets = {
  behaviors: [],
  rules: [],
  foundational: [],
  mid: [],
  complex: [],
  layouts: [],
  patterns: []
};

// -------------------------------------
// Functions
// -------------------------------------

/**
 * Returns a string with a capitalized first letter
 * @param {string} str incoming string
 * @returns {string} the capitalized string
 */
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Converts a library file's name to a matching string that will be
 * used to target an imported/exported library constructor.  This happens by replacing
 * filenames that use dashes followed by lowercase letters, to uppercase letters.
 * @param {string} str incoming string representing a filename
 * @returns {string} containing a matching constructor
 */
function replaceDashesWithCaptials(str) {
  str = capitalize(str);

  const matches = str.match(/(-\w)+/g);
  if (!matches) {
    return str;
  }

  matches.forEach((match) => {
    str = str.replace(match, capitalize(match.replace('-', '')));
  });
  return str;
}

/**
 * @param {string} str incoming string containing a file path
 * @returns {string} a string containing just a filename
 */
function getFileName(str) {
  const lastSlash = str.lastIndexOf(path.sep);
  if (lastSlash === -1 || lastSlash === (str.length - 1)) {
    return str;
  }
  return str.slice(lastSlash + 1);
}

/**
 * @param {string} str containing a file name
 * @returns {string} the library name
 */
function getLibFromFileName(str) {
  const dot = str.lastIndexOf('.');
  return str.substring(0, dot);
}

/**
 * @param {string} str containing a file name
 * @returns {string} the library path without the filename
 */
function getPath(str) {
  const lastSlash = str.lastIndexOf(path.sep);
  if (lastSlash === -1 || lastSlash === (str.length - 1)) {
    return str;
  }
  return str.substring(0, lastSlash + 1);
}

/**
 * Returns a string representing a valid Javascript ES6 `import` statement
 * @param {string} libFile the target library file
 * @param {string} libFolder the target library folder
 * @returns {string} a valid ES6 `import` statement
 */
function sanitizeLibFile(libFile, libFolder) {
  libFile = libFile.toLowerCase();
  if (!libFolder) {
    libFolder = libFile;
  } else {
    libFolder = libFolder.toLowerCase();
  }
  return libFile;
}

/**
 * Returns a string representing a valid Javascript ES6 `import` statement
 * @param {string} libFile the target library file
 * @param {string} libPath the target library folder
 * @param {boolean} isExport if true, export statement is used instead.
 * @param {boolean} noConstructor if true, don't import a constructor and import all file contents
 * @returns {string} a valid ES6 `import` statement
 */
function writeJSImportStatement(libFile, libPath, isExport, noConstructor) {
  libFile = sanitizeLibFile(libFile, libPath);
  const command = isExport ? 'export' : 'import';

  if (noConstructor) {
    return `${command} '${RELATIVE_SRC_DIR}/${libPath}${libFile}';`;
  }

  // (Temporarily) replace the filename with one that dash-separates the words
  // until we fix this later (see #833):
  let constructorName;
  if (dashSeparatedFileNames[libFile]) {
    constructorName = dashSeparatedFileNames[libFile];
    constructorName = replaceDashesWithCaptials(constructorName);
  } else if (lowercaseConstructorNames[libFile]) {
    constructorName = lowercaseConstructorNames[libFile];
  } else {
    constructorName = replaceDashesWithCaptials(libFile);
  }

  return `${command} { ${constructorName} } from '${RELATIVE_SRC_DIR}/${libPath}${libFile}';`;
}

/**
 * Returns a string representing a valid SASS `@import` statement
 * @param {string} libFile the target library file
 * @param {string} libPath the target libary folder
 * @returns {string} a valid SASS `@import` statement
 */
function writeSassImportStatement(libFile, libPath) {
  libFile = sanitizeLibFile(libFile, libPath);
  return `@import '${RELATIVE_SRC_DIR}/${libPath}${libFile}';`;
}

/**
 * @param {array} dirs an array of strings representing directories
 * @returns {void}
 */
function createDirs(dirs) {
  dirs.forEach((dir) => {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir);
      logger('info', `Created directory "${dir}"`);
    }
  });
}

/**
 * "cleans" all the folders used by this script
 * @returns {Promise} that resolves when the `del` library completes its task
 */
function cleanAll() {
  const filesToDel = [
    `${TEMP_DIR}/*.js`,
    `${TEMP_DIR}/*.scss`
  ];

  return del(filesToDel)
    .catch(err => logger('error', `Error: ${err}`))
    .then(() => {
      logger('success', `Cleaned directory "${TEMP_DIR}"`);
      createDirs([TEMP_DIR]);
    });
}

/**
 * Wraps `fs.readdir` and does a recursive file search
 * @param {string} root ?
 * @param {function} filter ?
 * @param {array} files ?
 * @param {string} prefix ?
 * @returns {array} of found files
 */
function read(root, filter, files, prefix) {
  prefix = prefix || '';
  files = files || [];
  filter = filter || function (x) {
    return x[0] !== '.' && !x.endsWith('.md');
  };

  const dir = path.join(root, prefix);
  if (!fs.existsSync(dir)) {
    return files;
  }

  if (fs.statSync(dir).isDirectory()) {
    fs.readdirSync(dir)
      .filter((name, index) => filter(name, index, dir))
      .forEach((name) => {
        read(root, filter, files, path.join(prefix, name));
      });
  } else {
    files.push(prefix);
  }

  return files;
}

/**
 * @param {array} files incoming file list
 * @param {string} term used for filtering the file list
 * @returns {array} a filtered version of the incoming array
 */
function searchFileNames(files, term) {
  const results = [];
  if (!Array.isArray(files) || !files.length || !term) {
    return results;
  }

  files.forEach((file) => {
    if (file.indexOf(term) === -1) {
      return;
    }

    // TODO: More granular sorting of component names (see #850).
    // fx: "builder" should not also match "listbuilder"

    results.push(file);
  });

  return results;
}

/**
 * Gets a copy of the standard `index.js` file.
 * @param {string} filePath the target file to be read.
 * @returns {string} containing the imported file.
 */
function getFileContents(filePath) {
  return fs.readFileSync(filePath, 'utf8');
}

/**
 * @param {string} str the string to search
 * @param {string} term the term to find
 * @returns {number} the location index of the search term, plus the term's length
 */
function getFurthestIndexOf(str, term) {
  return str.indexOf(term) + term.length;
}

/**
 * Sort Locations
 * @param {array} files incoming list of file paths
 * @param {string} srcFilePath path of the original component index file to use for sorting
 */
function sortFilesIntoBuckets(files, srcFilePath) {
  const matchStr = libTypes.slice(1).join('|');
  const matchRegex = new RegExp(matchStr, 'g');
  const locationKeys = Object.keys(customLocations);

  const componentsJSFile = getFileContents(srcFilePath);
  const startOfMid = getFurthestIndexOf(componentsJSFile, searchTerms.mid);
  const startOfComplex = getFurthestIndexOf(componentsJSFile, searchTerms.complex);

  files.forEach((file) => {
    let match = file.match(matchRegex);
    // No match === 'component' type.  In this case, further sort the sub-component type
    if (!match) {
      const fileName = getFileName(file);
      const lib = getLibFromFileName(fileName);

      // If the `lib` is defined with a custom location in this script,
      // prefer the bucket associated with it.
      if (locationKeys.indexOf(lib) !== -1) {
        const bucketKey = customLocations[lib];
        const bucket = buckets[bucketKey];
        if (Array.isArray(bucket)) {
          bucket.push(file);
        }
        return;
      }

      // Scan the `components.js` file for the location of this lib's name,
      // and determine its bucket placement based on its index,
      // compared to the headers' index in that file.
      const indexInJSFile = componentsJSFile.indexOf(lib);
      let targetBucket = buckets.foundational;
      if (indexInJSFile > startOfComplex) {
        targetBucket = buckets.complex;
      } else if (indexInJSFile > startOfMid) {
        targetBucket = buckets.mid;
      }

      targetBucket.push(file);
      return;
    }

    // Use first result
    match = match[0];

    // Ignore `utils` type for components
    if (match === 'utils') {
      return;
    }

    try {
      buckets[match].push(file);
    } catch (e) {
      throw new Error(`Sort Error: ${e}`);
    }
  });
}

/**
 * Writes the contents of a single file bucket to a string, for being appended to a file
 * @param {string} key the target file bucket
 * @param {string} type determines the type of file to include (see the types array inside)
 * @returns {string} formatted, multi-line, containing all relevant ES6-based import/export statements
 */
function renderImportsToString(key, type) {
  let fileContents = '';
  const bucket = buckets[key];
  if (!Array.isArray(bucket)) {
    throw new Error(`No bucket with name "${key}" exists.`);
  }

  const types = ['js', 'jquery', 'scss'];
  if (!type || types.indexOf(type) < 0) {
    type = types[0];
  }

  bucket.forEach((srcFilePath) => {
    const fileName = getFileName(srcFilePath);
    const filePath = getPath(srcFilePath);

    let ext = `.${type}`;
    if (type === 'jquery') {
      ext = `.${type}.js`;
    }

    // Don't write import/export statements for files that don't match
    // the type of index file we're creating.
    if (!fileName.endsWith(ext)) {
      return;
    }
    if (type === 'js' && fileName.indexOf('jquery') > -1) {
      return;
    }

    const lib = getLibFromFileName(fileName);

    let statement = '';
    if (type === 'scss') {
      statement = writeSassImportStatement(lib, filePath, true);
    } else if (type === 'jquery') {
      statement = writeJSImportStatement(lib, filePath, false, true);
    } else {
      statement = writeJSImportStatement(lib, filePath, true);
    }
    fileContents += `${statement}\n`;
  });

  return fileContents;
}

/**
 * @private
 * @param {string} targetFilePath the path of the file that will be written
 * @param {string} targetFile the contents of the file to be written
 * @returns {Promise} results of `fs.writeFile()`
 */
function writeFile(targetFilePath, targetFile) {
  return fs.writeFile(targetFilePath, targetFile, (err) => {
    if (err) {
      logger('error', `${err}`);
      return;
    }
    logger('success', `"${targetFilePath}" saved!`);
  });
}

/**
 * Writes a JS file containing regular ES6 Imports (not jQuery)
 * @private
 * @param {string} key the file path bucket to use
 * @param {string} targetFilePath the path of the file that will be written
 * @returns {Promise} containing the results of the file write
 */
function renderTargetJSFile(key, targetFilePath) {
  let targetFile = '';
  const type = 'js';

  if (key === 'index') {
    // Pull in the standard `index.js` file and create a custom version that links
    // out to other JS files that will import slimmed-down lists of components.
    // Saves to the `temp/` folder.
    targetFile = getFileContents(filePaths.src.js.index);
    targetFile = targetFile
      .replace(/('\.\/)/g, '\'../src/')
      .replace('../src/behaviors/behaviors', './behaviors')
      .replace('../src/core/rules', './rules')
      .replace('../src/components/components', './components')
      .replace('../src/patterns/patterns', './patterns')
      .replace('../src/behaviors/initialize/initialize.jquery', './initialize.jquery');
  } else if (key === 'initialize') {
    targetFile = getFileContents(filePaths.src.js.initialize);
    targetFile = targetFile
      .replace(/('\.\.\/)((?!\.))/g, '\'./')
      .replace(/('\.\.\/\.\.\/)/g, '\'../src/')
      .replace('../src/components/components.jquery', './components.jquery')
      .replace('../src/patterns/patterns.jquery', './patterns.jquery');
  } else if (key === 'components') {
    // 'component' source code files are comprised of three buckets that need to
    // be written to the target file in a specific order.
    const componentBuckets = ['foundational', 'mid', 'complex'];
    componentBuckets.forEach((thisBucket) => {
      targetFile += `// ${capitalize(thisBucket)} ====/\n`;
      targetFile += renderImportsToString(thisBucket, type);
      targetFile += '\n';
    });
  } else {
    // All other buckets simply get rendered directly
    targetFile += renderImportsToString(key, type);
  }

  return writeFile(targetFilePath, targetFile);
}

/**
 * Writes a JS file containing regular jQuery-based `import` statements
 * @private
 * @param {string} key the file path bucket to use
 * @param {string} targetFilePath the path of the file that will be written
 * @returns {Promise} containing the results of the file write
 */
function renderTargetJQueryFile(key, targetFilePath) {
  let targetFile = '';
  const type = 'jquery';

  if (key === 'components') {
    // 'component' source code files are comprised of three buckets that need to
    // be written to the target file in a specific order.
    const componentBuckets = ['foundational', 'mid', 'complex'];
    componentBuckets.forEach((thisBucket) => {
      targetFile += `// ${capitalize(thisBucket)} ====/\n`;
      targetFile += renderImportsToString(thisBucket, type);
      targetFile += '\n';
    });
  } else if (key === 'initialize') {
    targetFile = getFileContents(filePaths.src.jQuery.initialize);
  } else {
    // All other buckets simply get rendered directly
    targetFile += renderImportsToString(key, type);
  }

  return writeFile(targetFilePath, targetFile);
}

/**
 * Writes a SASS file containing `import` statements for other components
 * @private
 * @param {string} key the file path bucket to use
 * @param {string} targetFilePath the path of the file that will be written
 * @returns {Promise} containing the results of the file write
 */
function renderTargetSassFile(key, targetFilePath) {
  let targetFile = '';
  const type = 'scss';

  if (key === 'components') {
    targetFile = '// Required ====/\n@import \'../src/core/required\';\n\n';

    // 'component' source code files are comprised of three buckets that need to
    // be written to the target file in a specific order.
    const componentBuckets = ['foundational', 'mid', 'complex', 'patterns', 'layouts'];
    componentBuckets.forEach((thisBucket) => {
      targetFile += `// ${capitalize(thisBucket)} ====/\n`;
      targetFile += renderImportsToString(thisBucket, type);
      targetFile += '\n';
    });
    targetFile += '// These controls must come last\n@import \'../src/components/colors/colors\';\n';
  } else {
    // All other keys are "theme" entry points that just need their linked paths corrected.
    const themeFile = getFileContents(path.join(SRC_DIR, 'themes', `${key}.scss`));
    targetFile = themeFile
      .replace(/('\.\.\/)((?!\.))/g, '\'../src/') // replaces anything pointing to a source code file
      .replace(/(\.\.\/)\1/g, '../') // fixes the node_modules link to IDS Identity
      .replace('../src/core/controls', './controls');
  }

  return writeFile(targetFilePath, targetFile);
}

/**
 * Renders all available target files.
 * @returns {Promise} containing all file writes.
 */
function renderTargetFiles() {
  const jsEntryPoints = Object.keys(filePaths.target.js);
  const jQueryEntryPoints = Object.keys(filePaths.target.jQuery);
  const sassThemes = Object.keys(filePaths.target.sass.themes);
  const renderPromises = [];

  jsEntryPoints.forEach((filePathKey) => {
    renderPromises.push(renderTargetJSFile(filePathKey, filePaths.target.js[filePathKey]));
  });

  jQueryEntryPoints.forEach((filePathKey) => {
    renderPromises.push(renderTargetJQueryFile(filePathKey, filePaths.target.jQuery[filePathKey]));
  });

  sassThemes.forEach((filePathKey) => {
    const p = renderTargetSassFile(filePathKey, filePaths.target.sass.themes[filePathKey]);
    renderPromises.push(p);
  });
  renderPromises.push(renderTargetSassFile('components', filePaths.target.sass.controls));

  return Promise.all(renderPromises);
}

// -------------------------------------
// Main
// -------------------------------------

logger(null, `\n${chalk.red.bold('IDS Enterprise Custom Builder')}\n`);

let buildOutput = '';

if (!commandLineArgs.components) {
  logger(null, 'No component arguments were provided to the custom builder.  Exiting...');
  process.exit(0);
}

// Convert command line args to a usable list of components
const requestedComponents = commandLineArgs.components.split(',');

cleanAll().then(() => {
  // Display a list of requested components to the console
  let componentList = `\n${chalk.bold('Searching files in `src/` for the following terms:')}\n`;
  requestedComponents.forEach((comp) => {
    componentList += `- ${comp}\n`;
  });
  logger(null, componentList);

  // Scan source code directories
  const items = read(SRC_DIR);

  // Build several lists of component source code files that match what was requested
  const jsMatches = [];
  const jQueryMatches = [];
  const sassMatches = [];

  // Search the stored list of source files for each term
  requestedComponents.forEach((arg) => {
    const results = searchFileNames(items, arg);
    results.forEach((result) => {
      let renderTarget = jsMatches;
      if (result.indexOf('.jquery') > -1) {
        renderTarget = jQueryMatches;
      }
      if (result.endsWith('.scss')) {
        renderTarget = sassMatches;
      }
      if (renderTarget.indexOf(result) > -1) {
        return;
      }
      renderTarget.push(result);
    });
  });

  buildOutput += `${chalk.cyan('JS Source Code:')}\n`;
  jsMatches.forEach((item) => {
    buildOutput += `${item}\n`;
  });
  buildOutput += '\n';

  buildOutput += `${chalk.cyan('jQuery Source Code:')}\n`;
  jQueryMatches.forEach((item) => {
    buildOutput += `${item}\n`;
  });
  buildOutput += '\n';

  buildOutput += `${chalk.cyan('SASS Source Code:')}\n`;
  sassMatches.forEach((item) => {
    buildOutput += `${item}\n`;
  });
  buildOutput += '\n';

  process.stdout.write(buildOutput);

  // Create customized lists of JS components for this bundle
  sortFilesIntoBuckets(jsMatches, filePaths.src.js.components);
  sortFilesIntoBuckets(jQueryMatches, filePaths.src.jQuery.components);
  sortFilesIntoBuckets(sassMatches, filePaths.src.sass.controls);

  renderTargetFiles().then(() => {
    const buildProcesses = [];
    let rollupBuildLog = '';
    let sassBuildLog = '';

    // Copy vendor libs/dependencies
    const copyPromise = new Promise((resolve, reject) => {
      const copy = spawn('npx', ['grunt', 'copy:main']);
      copy.on('exit', (code) => {
        if (code !== 0) {
          reject(new Error(`Copy exited with error code (${code})`));
        }
        resolve();
      });
    });
    buildProcesses.push(copyPromise);

    if (jsMatches.length || jQueryMatches.length) {
      const jsBuildPromise = new Promise((resolve, reject) => {
        const rollup = spawn('rollup', ['-c', '--customBuild', `--components=${commandLineArgs.components}`]);
        rollup.stdout.on('data', (data) => {
          rollupBuildLog += `${data}\n`;
        });
        rollup.on('exit', (code) => {
          if (code !== 0) {
            reject(new Error(`Rollup build exited with error code (${code})`));
          }
          resolve();
        });
      });

      buildProcesses.push(jsBuildPromise);
    }

    if (sassMatches.length) {
      const sassBuildPromise = new Promise((resolve, reject) => {
        const nodeSass = spawn('grunt', ['build:sass', `--components=${commandLineArgs.components}`]);
        nodeSass.stdout.on('data', (data) => {
          sassBuildLog += `${data}\n`;
        });
        nodeSass.on('exit', (code) => {
          if (code !== 0) {
            reject(new Error(`Sass build exited with error code (${code})`));
          }
          resolve();
        });
      });
      buildProcesses.push(sassBuildPromise);
    }

    Promise.all(buildProcesses).then(() => {
      process.stdout.write(`${rollupBuildLog}\n${sassBuildLog}`);
      process.exit(0);
    }).catch((reason) => {
      logger('error', `${reason}`);
      process.stdout.write(`${rollupBuildLog}\n${sassBuildLog}`);
      process.exit(1);
    });
  });
});
